<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blog - Sajay</title>
    <link rel="stylesheet" href="layout.css">
    <link rel="stylesheet" href="styles.css">
    <style>
        .blog-grid {
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            gap: 2rem;
            margin-top: 80px;
        }

        .blog-entry {
            position: relative;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 1.5rem 1.5rem 1.5rem 140px;
            min-height: 140px;
            transition: background 0.3s ease;
            font-family: ui-monospace, "Cascadia Mono", "Segoe UI Mono",
                        "Liberation Mono", Menlo, Monaco, Consolas, monospace;
        }

        .blog-entry:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .pattern-container {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 100px;
            height: 100px;
            border-radius: 8px;
            overflow: hidden;
            opacity: 0.7;
            transition: opacity 0.3s ease;
        }

        .blog-entry:hover .pattern-container {
            opacity: 1;
        }

        .blog-title {
            font-size: var(--text-2xl);
            margin-bottom: 0.5rem;
            color: var(--text-primary);
            font-weight: 400;
            letter-spacing: -0.5px;
            line-height: 1.2;
        }

        .blog-subtitle {
            font-size: var(--text-base);
            color: var(--text-secondary);
            opacity: 0.8;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <!-- Background Effects Container -->
    <div id="background-effects">
        <div id="dappled-light">
            <div id="glow"></div>
            <div id="glow-bounce"></div>
            <div class="perspective">
                <div id="leaves">
                    <svg style="width: 0; height: 0; position: absolute;">
                        <defs>
                            <filter id="wind" x="-20%" y="-20%" width="140%" height="140%">
                                <feTurbulence type="fractalNoise" numOctaves="2" seed="1">
                                    <animate attributeName="baseFrequency" dur="16s" keyTimes="0;0.33;0.66;1"
                                        values="0.005 0.003;0.01 0.009;0.008 0.004;0.005 0.003" repeatCount="indefinite" />
                                </feTurbulence>
                                <feDisplacementMap in="SourceGraphic">
                                    <animate attributeName="scale" dur="20s" keyTimes="0;0.25;0.5;0.75;1"
                                        values="45;55;75;55;45" repeatCount="indefinite" />
                                </feDisplacementMap>
                            </filter>
                        </defs>
                    </svg>
                </div>
                <div id="blinds">
                    <div class="shutters">
                        <div class="shutter"></div>
                        <div class="shutter"></div>
                        <div class="shutter"></div>
                        <div class="shutter"></div>
                        <div class="shutter"></div>
                        <div class="shutter"></div>
                        <div class="shutter"></div>
                        <div class="shutter"></div>
                        <div class="shutter"></div>
                        <div class="shutter"></div>
                        <div class="shutter"></div>
                        <div class="shutter"></div>
                        <div class="shutter"></div>
                        <div class="shutter"></div>
                        <div class="shutter"></div>
                    </div>
                    <div class="vertical">
                        <div class="bar"></div>
                        <div class="bar"></div>
                    </div>
                </div>
            </div>
            <div id="progressive-blur">
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
        </div>
    </div>

    <!-- Main Scrollable Container -->
    <div id="scroll-container">
        <header class="header">
            <div class="header-content">
                <a href="index.html" class="logo">Sajay</a>
                <nav class="nav">
                    <a href="index.html" class="nav-item">Home</a>
                    <a href="blog.html" class="nav-item active">Blogs</a>
                    <a href="/projects" class="nav-item">Cool stuff</a>
                    <button class="theme-toggle">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                             stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="5"/>
                            <path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2
                                     M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/>
                        </svg>
                    </button>
                </nav>
            </div>
        </header>

        <!-- Blog Grid -->
        <main class="blog-grid">
            <article class="blog-entry">
                <div class="pattern-container"></div>
                <h2 class="blog-title">Understanding Neural Networks</h2>
                <p class="blog-subtitle">A deep dive into the fundamentals of deep learning</p>
            </article>

            <article class="blog-entry">
                <div class="pattern-container"></div>
                <h2 class="blog-title">Computer Vision Projects</h2>
                <p class="blog-subtitle">Exploring unsupervised learning in visual tasks</p>
            </article>

            <article class="blog-entry">
                <div class="pattern-container"></div>
                <h2 class="blog-title">LLM Architecture Deep Dive</h2>
                <p class="blog-subtitle">Breaking down the components of large language models</p>
            </article>
        </main>
    </div>

    <script src="script.js"></script>
    <script>
        class GeometricPattern {
            constructor(container, options = {}) {
                this.container = container;
                this.options = {
                    width: options.width || 100,
                    height: options.height || 100,
                    gridSize: options.gridSize || 10,
                    lineColor: options.lineColor || 'currentColor',
                    lineWidth: options.lineWidth || 1,
                    minPaths: options.minPaths || 8,
                    maxPaths: options.maxPaths || 15,
                    opacity: options.opacity || 1
                };
                
                this.points = [];
                this.paths = [];
                this.svg = null;
                
                this.init();
            }
            
            init() {
                this.svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                this.svg.setAttribute('width', this.options.width);
                this.svg.setAttribute('height', this.options.height);
                this.svg.style.opacity = this.options.opacity;
                
                this.generatePoints();
                this.generatePaths();
                this.render();
                
                this.container.appendChild(this.svg);
            }
            
            generatePoints() {
                const cellWidth = this.options.width / this.options.gridSize;
                const cellHeight = this.options.height / this.options.gridSize;
                
                for (let i = 0; i <= this.options.gridSize; i++) {
                    for (let j = 0; j <= this.options.gridSize; j++) {
                        if (Math.random() < 0.4) {
                            this.points.push({
                                x: j * cellWidth + (Math.random() - 0.5) * cellWidth * 0.5,
                                y: i * cellHeight + (Math.random() - 0.5) * cellHeight * 0.5
                            });
                        }
                    }
                }
            }
            
            generatePaths() {
                const numPaths = Math.floor(
                    Math.random() * 
                    (this.options.maxPaths - this.options.minPaths) + 
                    this.options.minPaths
                );
                
                for (let i = 0; i < numPaths; i++) {
                    if (this.points.length < 2) break;
                    
                    const pathType = Math.random();
                    if (pathType < 0.4) {
                        this.generateBezierCurve();
                    } else if (pathType < 0.7) {
                        this.generateArc();
                    } else {
                        this.generateSmoothLine();
                    }
                }
            }

            generateBezierCurve() {
                const start = this.points[Math.floor(Math.random() * this.points.length)];
                const end = this.points[Math.floor(Math.random() * this.points.length)];
                
                // Generate control points for the BÃ©zier curve
                const ctrl1 = {
                    x: start.x + (Math.random() - 0.5) * this.options.width * 0.8,
                    y: start.y + (Math.random() - 0.5) * this.options.height * 0.8
                };
                const ctrl2 = {
                    x: end.x + (Math.random() - 0.5) * this.options.width * 0.8,
                    y: end.y + (Math.random() - 0.5) * this.options.height * 0.8
                };
                
                this.paths.push({
                    type: 'bezier',
                    start,
                    end,
                    ctrl1,
                    ctrl2
                });
            }

            generateArc() {
                const center = this.points[Math.floor(Math.random() * this.points.length)];
                const radius = Math.random() * this.options.width * 0.3;
                const startAngle = Math.random() * Math.PI * 2;
                const endAngle = startAngle + Math.random() * Math.PI;
                
                this.paths.push({
                    type: 'arc',
                    center,
                    radius,
                    startAngle,
                    endAngle
                });
            }

            generateSmoothLine() {
                const start = this.points[Math.floor(Math.random() * this.points.length)];
                const end = this.points[Math.floor(Math.random() * this.points.length)];
                
                this.paths.push({
                    type: 'smooth',
                    start,
                    end
                });
            }
            
            render() {
                this.paths.forEach(path => {
                    let element;
                    
                    switch (path.type) {
                        case 'bezier':
                            element = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                            element.setAttribute('d', `M ${path.start.x} ${path.start.y} C ${path.ctrl1.x} ${path.ctrl1.y}, ${path.ctrl2.x} ${path.ctrl2.y}, ${path.end.x} ${path.end.y}`);
                            break;
                            
                        case 'arc':
                            const startX = path.center.x + path.radius * Math.cos(path.startAngle);
                            const startY = path.center.y + path.radius * Math.sin(path.startAngle);
                            const endX = path.center.x + path.radius * Math.cos(path.endAngle);
                            const endY = path.center.y + path.radius * Math.sin(path.endAngle);
                            
                            element = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                            element.setAttribute('d', `M ${startX} ${startY} A ${path.radius} ${path.radius} 0 0 1 ${endX} ${endY}`);
                            break;
                            
                        case 'smooth':
                            element = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                            const midX = (path.start.x + path.end.x) / 2;
                            const midY = (path.start.y + path.end.y) / 2 + (Math.random() - 0.5) * 20;
                            element.setAttribute('d', `M ${path.start.x} ${path.start.y} Q ${midX} ${midY} ${path.end.x} ${path.end.y}`);
                            break;
                    }
                    
                    element.setAttribute('stroke', this.options.lineColor);
                    element.setAttribute('stroke-width', this.options.lineWidth);
                    element.setAttribute('fill', 'none');
                    this.svg.appendChild(element);
                });
            }
        }

        // Initialize patterns for each blog entry
        document.querySelectorAll('.pattern-container').forEach(container => {
            new GeometricPattern(container, {
                width: 100,
                height: 100,
                gridSize: 6,
                lineColor: 'currentColor',
                lineWidth: 1.5,
                minPaths: 8,
                maxPaths: 15,
                opacity: 1
            });
        });
    </script>
</body>
</html> 